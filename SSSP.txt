#DJIKSTRA

#include<iostream>
#include <vector>
#include<queue>

using namespace std;

class Graph
{
private:
    int V;
    int E;
    vector<vector<pair<int,int>>> adj;
public:
    Graph(int v,int e)
    {
        V=v;
        E=e;
        int first,second,weight;
        adj.resize(V+1);
        for (int i=0;i<E;i++)
        {
            cin>>first>>second>>weight;
            adj[first].push_back({second,weight});
        }
    }
    void printGraph()
    {
        for (int i=1;i<V+1;i++)
        {
            cout<<i<<"=";
            for (auto j:adj[i])
            {
                cout<<j.first<<" "<<j.second<<" ";
            }
            cout<<endl;
        }
    }

    int djikstra(int src)
    {
        vector<int> nocoupondist(V+1,INT_MAX);
        vector<int> coupondist(V+1,INT_MAX);
        nocoupondist[src]=0;
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;
        pq.push({0,src,0});
        while (!pq.empty())
        {
            vector<int> top= pq.top();
            pq.pop();
            int currentdistance=top[0];
            int u=top[1];
            int coupon=top[2];
            if (coupon==0&&currentdistance!=nocoupondist[u]) continue;
            if (coupon==1&&currentdistance!=coupondist[u]) continue;
            for (auto edge:adj[u])
            {
                int v=edge.first;
                int w=edge.second;
                if (coupon==0&&nocoupondist[u]+w<nocoupondist[v])
                {
                    nocoupondist[v]=nocoupondist[u]+w;
                    pq.push({nocoupondist[v],v,0});
                }
                if (coupon==1&&coupondist[u]+w<coupondist[v])
                {
                    coupondist[v]=coupondist[u]+w;
                    pq.push({coupondist[v],v,1});
                }
                if (coupon==0&&nocoupondist[u]+w/2<coupondist[v])
                {
                    coupondist[v]=nocoupondist[u]+w/2;
                    pq.push({coupondist[v],v,1});
                }
            }
        }
        if (nocoupondist[V]<nocoupondist[V]) return nocoupondist[V];
        return coupondist[V];
    }
    // int djikstra(int src) //normal djikstra
    // {
    //     vector<int> dist(V+1, INT_MAX);
    //     dist[src]=0;
    //     priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
    //     pq.push({0, src});
    //     while (!pq.empty())
    //     {
    //         pair<int,int> top=pq.top();
    //         u=top.first;
    //         d=top.second;
    //         pq.pop();
    //         if (d!=dist[u]) continue;
    //         for (auto edge:adj[u])
    //         {
    //             int v=edge.first;
    //             int w=edge.second;
    //             if (dist[u]+w<dist[v])
    //             {
    //                 dist[v]=dist[u]+w;
    //                 pq.push({dist[v],v});
    //             }
    //         }
    //     }
    //     return dist[V];
    // }
    // int halfEdgeDjikstra(int src) //shob edge aladavabe halve kore
    // {
    //     int mincost=djikstra(src);
    //     for (int u=1;u<=V;u++)
    //     {
    //         for (int j=0;j<adj[u].size();j++)
    //         {
    //             int puran=adj[u][j].second;
    //             adj[u][j].second=puran/2;
    //             int notun=djikstra(src);
    //             minCost=min(minCost,notun);
    //             adj[u][j].second=puran;
    //         }
    //     }
    //     return minCost;
    // }
};
int main()
{
    int v,e;
    cin>>v>>e;
    Graph g(v,e);
    //g.printGraph();
    cout<<g.djikstra(1)<<endl;
    return 0;
}










#BELLMANFORD

#include <iostream>
#include<vector>
#include<algorithm>
using namespace std;

class Graph
{
private:
    int V;
    int E;
    vector<vector<pair<int,int>>> adj;
public:
    Graph(int v,int e)
    {
        V=v;
        E=e;
        int first,second,weight;
        adj.resize(V+1);
        for (int i=0;i<E;i++)
        {
            cin>>first>>second>>weight;
            adj[first].push_back({second,weight});
        }
    }
    void printGraph()
    {
        for (int i=1;i<V+1;i++)
        {
            cout<<i<<"->";
            for (auto j:adj[i])
            {
                cout<<j.first<<" "<<j.second<<" ";
            }
            cout<<endl;
        }
    }
    vector<int> bellmanFord()
    {
        //vector<int> dist(V+1,INT_MAX);
        vector<int> dist(V+1,0);
        vector<int> parent(V+1,-1);
        int destiny=-1;
        for (int i=0;i<V-1;i++)
        {
            for (int j=1;j<V+1;j++)
            {
                for (auto edge:adj[j])
                {
                    int u=j;
                    int v=edge.first;
                    int w=edge.second;
                    if (dist[u]+w<dist[v])
                    {
                        dist[v]=dist[u]+w;
                        parent[v]=u;
                    }
                }
            }
        }
        for (int j=1;j<V+1;j++)
        {
            for (auto edge:adj[j])
            {
                int u=j;
                int v=edge.first;
                int w=edge.second;
                if (dist[u]+w<dist[v])
                {
                    destiny=v;
                    parent[v]=u;
                }
            }
        }
        if (destiny==-1) return {-1};
        for (int i=0;i<V;i++)
        {
            destiny=parent[destiny];
        }
        vector<int> answer;
        int present=destiny;
        bool firsttime=true;
        while (present!=destiny||firsttime)
        {
            answer.push_back(present);
            present=parent[present];
            firsttime=false;
        }
        reverse(answer.begin(),answer.end());
        return answer;
    }
};

int main()
{
    int v,e;
    cin>>v>>e;
    Graph g(v,e);
    // g.printGraph();
    vector<int> answer=g.bellmanFord();
    for (int vertex:answer)
    {
        cout<<vertex<<" ";
    }
    cout<<endl;
    return 0;
}








#BFS
void bfs(int src)
{
    vector<bool> visited(V+1, false);
    queue<int> q;

    visited[src] = true;
    q.push(src);

    while (!q.empty())
    {
        int u = q.front();
        q.pop();

        cout << u << " ";

        for (auto edge : adj[u])
        {
            int v = edge.first;
            if (!visited[v])
            {
                visited[v] = true;
                q.push(v);
            }
        }
    }
    cout << endl;
}










#DFS

void dfsUtil(int u, vector<bool>& visited)
{
    visited[u] = true;
    cout << u << " ";

    for (auto edge : adj[u])
    {
        int v = edge.first;
        if (!visited[v])
        {
            dfsUtil(v, visited);
        }
    }
}

void dfs(int src)
{
    vector<bool> visited(V+1, false);
    dfsUtil(src, visited);
    cout << endl;
}






#BUILDFROMGRID


void buildFromGrid(const vector<vector<int>>& grid)
{
    int rows = grid.size();
    int cols = grid[0].size();

    V = rows * cols;
    adj.clear();
    adj.resize(V + 1);

    auto id = [&](int i, int j) {
        return i * cols + j + 1;
    };

    int dx[4] = {-1, 1, 0, 0};
    int dy[4] = {0, 0, -1, 1};

    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            int u = id(i, j);

            for (int d = 0; d < 4; d++)
            {
                int ni = i + dx[d];
                int nj = j + dy[d];

                if (ni >= 0 && ni < rows && nj >= 0 && nj < cols)
                {
                    int v = id(ni, nj);
                    int w = 1; // weight (change if needed)

                    adj[u].push_back({v, w});
                }
            }
        }
    }
}








if (grid[i][j] == -1) continue;
int w = grid[ni][nj];


long long dijkstra_two_coupons(int src)
{
    const int MAXC = 2;
    vector<vector<long long>> dist(MAXC+1, vector<long long>(V+1, LLONG_MAX));

    priority_queue<
        vector<long long>,
        vector<vector<long long>>,
        greater<vector<long long>>
    > pq;

    dist[0][src] = 0;
    pq.push({0, src, 0});

    while (!pq.empty())
    {
        auto top = pq.top(); pq.pop();
        long long d = top[0];
        int u = top[1];
        int c = top[2];

        if (d != dist[c][u]) continue;

        for (auto edge : adj[u])
        {
            int v = edge.first;
            int w = edge.second;

            // No coupon
            if (d + w < dist[c][v])
            {
                dist[c][v] = d + w;
                pq.push({dist[c][v], v, c});
            }

            // Use coupon
            if (c < MAXC && d + w/2 < dist[c+1][v])
            {
                dist[c+1][v] = d + w/2;
                pq.push({dist[c+1][v], v, c+1});
            }
        }
    }

    return min({dist[0][V], dist[1][V], dist[2][V]});
}



